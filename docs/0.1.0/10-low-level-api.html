<!DOCTYPE html PUBLIC ""
    "">
<html><head><meta charset="UTF-8" /><link href="css/default.css" rel="stylesheet" type="text/css" /><script src="js/jquery.min.js" type="text/javascript"></script><script src="js/page_effects.js" type="text/javascript"></script><title>Clojang User's Guide: The Low-level API</title></head><body><div id="header"><h2>Generated by <a href="https://github.com/weavejester/codox">Codox</a></h2><h1><a href="index.html"><span class="project-title"><span class="project-name">jiface</span> <span class="project-version">0.1.0</span></span></a></h1></div><div class="sidebar primary"><h3 class="no-link"><span class="inner">Project</span></h3><ul class="index-link"><li class="depth-1 "><a href="index.html"><div class="inner">Index</div></a></li></ul><h3 class="no-link"><span class="inner">Topics</span></h3><ul><li class="depth-1  current"><a href="10-low-level-api.html"><div class="inner"><span>Clojang User's Guide: The Low-level API</span></div></a></li><li class="depth-1 "><a href="80-building-jinterface.html"><div class="inner"><span>Building JInterface for Clojure</span></div></a></li><li class="depth-1 "><a href="98-other-resources.html"><div class="inner"><span>Other Resources</span></div></a></li><li class="depth-1 "><a href="99-other-versions.html"><div class="inner"><span>API Docs (All Versions)</span></div></a></li></ul><h3 class="no-link"><span class="inner">Namespaces</span></h3><ul><li class="depth-1"><div class="no-link"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>jiface</span></div></div></li><li class="depth-2"><a href="jiface.erlang.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>erlang</span></div></a></li><li class="depth-3 branch"><a href="jiface.erlang.atom.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>atom</span></div></a></li><li class="depth-3 branch"><a href="jiface.erlang.float.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>float</span></div></a></li><li class="depth-3 branch"><a href="jiface.erlang.int.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>int</span></div></a></li><li class="depth-3 branch"><a href="jiface.erlang.list.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>list</span></div></a></li><li class="depth-3 branch"><a href="jiface.erlang.map.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>map</span></div></a></li><li class="depth-3 branch"><a href="jiface.erlang.object.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>object</span></div></a></li><li class="depth-3 branch"><a href="jiface.erlang.pid.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>pid</span></div></a></li><li class="depth-3 branch"><a href="jiface.erlang.port.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>port</span></div></a></li><li class="depth-3 branch"><a href="jiface.erlang.string.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>string</span></div></a></li><li class="depth-3 branch"><a href="jiface.erlang.tuple.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>tuple</span></div></a></li><li class="depth-3"><a href="jiface.erlang.types.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>types</span></div></a></li><li class="depth-2"><a href="jiface.otp.html"><div class="inner"><span class="tree" style="top: -362px;"><span class="top" style="height: 371px;"></span><span class="bottom"></span></span><span>otp</span></div></a></li><li class="depth-3 branch"><a href="jiface.otp.connection.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>connection</span></div></a></li><li class="depth-3 branch"><a href="jiface.otp.messaging.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>messaging</span></div></a></li><li class="depth-3 branch"><a href="jiface.otp.nodes.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>nodes</span></div></a></li><li class="depth-3 branch"><a href="jiface.otp.streams.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>streams</span></div></a></li><li class="depth-3"><a href="jiface.otp.transport.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>transport</span></div></a></li><li class="depth-2"><a href="jiface.util.html"><div class="inner"><span class="tree" style="top: -176px;"><span class="top" style="height: 185px;"></span><span class="bottom"></span></span><span>util</span></div></a></li></ul></div><div class="document" id="content"><div class="doc"><div class="markdown"><h1><a href="#clojang-users-guide-the-low-level-api" name="clojang-users-guide-the-low-level-api"></a>Clojang User’s Guide: The Low-level API</h1>
<h2><a href="#the-jinterface-package-in-clojang" name="the-jinterface-package-in-clojang"></a>The JInterface Package in Clojang</h2>
<p><strong>NOTICE</strong>: This document is a copy of the JInterface Users Guide, <a href="erlang/jinterface_users_guide.html">a version of which</a> is provided in the published documentation for the Clojang project.</p>
<p>The <a href="erlang/java/com/ericsson/otp/erlang/package-summary.html">Jinterface</a> package provides a set of tools for communication with Erlang processes. It can also be used for communication with other Java processes using the same package, as well as C processes using the Erl_Interface library.</p>
<p>The set of classes in the package can be divided into two categories: those that provide the actual communication, and those that provide a Java representation of the Erlang data types. The latter are all subclasses of OtpErlangObject, and they are identified by the <code>OtpErlang</code> prefix.</p>
<p>Since this package provides a mechanism for communicating with Erlang, message recipients can be Erlang processes or instances of com.ericsson.otp.erlang.OtpMbox, both of which are identified with pids and possibly registered names. When pids or mailboxes are mentioned as message senders or recipients in this section, it should assumed that even Erlang processes are included, unless specified otherwise. The classes in <a href="erlang/java/com/ericsson/otp/erlang/package-summary.html">Jinterface</a> support the following:</p>
<ul>
  <li>manipulation of data represented as Erlang data types</li>
  <li>conversion of data between Java and Erlang formats</li>
  <li>encoding and decoding of Erlang data types for transmission or storage</li>
  <li>communication between Java nodes and Erlang processes</li>
</ul>
<p>In the following sections, these topics are described:</p>
<ul>
  <li>mapping of Erlang types to Java</li>
  <li>encoding, decoding, and sending Erlang terms</li>
  <li>connecting to a distributed Erlang node</li>
  <li>using nodes, mailboxes and EPMD</li>
  <li>sending and receiving Erlang messages and data</li>
  <li>remote procedure calls</li>
  <li>linking to remote processes</li>
  <li>compiling your code for use with Jinterface</li>
  <li>tracing message flow</li>
</ul>
<p><a href="http://oubiwann.github.io/clojang/current/clojang.jinterface.erlang.types.html#var-atom">http://oubiwann.github.io/clojang/current/clojang.jinterface.erlang.types.html#var-atom</a></p>
<h2><a href="#mapping-of-basic-erlang-types-to-the-jvm" name="mapping-of-basic-erlang-types-to-the-jvm"></a>Mapping of Basic Erlang Types to the JVM</h2>
<p>This section describes the mapping of Erlang basic types to JVM types.</p>
<table>
  <thead>
    <tr>
      <th>Erlang type </th>
      <th>JVM type</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>atom </td>
      <td><a href="clojang/current/clojang.jinterface.erlang.atom.html">atom</a></td>
    </tr>
    <tr>
      <td>binary </td>
      <td><a href="erlang/java/com/ericsson/otp/erlang/OtpErlangBinary.html">OtpErlangBinary</a></td>
    </tr>
    <tr>
      <td>floating point types </td>
      <td><a href="erlang/java/com/ericsson/otp/erlang/OtpErlangFloat.html">OtpErlangFloat</a> or <a href="erlang/java/com/ericsson/otp/erlang/OtpErlangDouble.html">OtpErlangDouble</a>, depending on the floating point value size</td>
    </tr>
    <tr>
      <td>integral types </td>
      <td>One of <a href="erlang/java/com/ericsson/otp/erlang/OtpErlangByte.html">OtpErlangByte</a>, <a href="clojang.jinterface.erlang.types.html#var-charhtml">char</a>,<a href="erlang/java/com/ericsson/otp/erlang/OtpErlangShort.html">OtpErlangShort</a>, <a href="erlang/java/com/ericsson/otp/erlang/OtpErlangUShort.html">OtpErlangUShort</a>,<a href="erlang/java/com/ericsson/otp/erlang/OtpErlangInt.html">OtpErlangInt</a>,<a href="erlang/java/com/ericsson/otp/erlang/OtpErlangUInt.html">OtpErlangUInt</a> or <a href="erlang/java/com/ericsson/otp/erlang/OtpErlangLong.html">OtpErlangLong</a>, depending on the integral value size and sign</td>
    </tr>
    <tr>
      <td>list </td>
      <td><a href="clojang/current/clojang.jinterface.erlang.list.html">list</a></td>
    </tr>
    <tr>
      <td>pid </td>
      <td><a href="erlang/java/com/ericsson/otp/erlang/OtpErlangPid.html">OtpErlangPid</a></td>
    </tr>
    <tr>
      <td>port </td>
      <td><a href="erlang/java/com/ericsson/otp/erlang/OtpErlangPort.html">OtpErlangPort</a></td>
    </tr>
    <tr>
      <td>ref </td>
      <td><a href="erlang/java/com/ericsson/otp/erlang/OtpErlangRef.html">OtpErlangRef</a></td>
    </tr>
    <tr>
      <td>tuple </td>
      <td><a href="clojang.jinterface.erlang.types.html#var-tuple.html">tuple</a></td>
    </tr>
    <tr>
      <td>map </td>
      <td><a href="erlang/java/com/ericsson/otp/erlang/OtpErlangMap.html">OtpErlangMap</a></td>
    </tr>
    <tr>
      <td>term </td>
      <td><a href="clojang/current/clojang.jinterface.erlang.object.html">OtpErlangObject</a></td>
    </tr>
  </tbody>
</table>
<h2><a href="#special-mapping-issues" name="special-mapping-issues"></a>Special Mapping Issues</h2>
<p>The atoms <code>true</code> and <code>false</code> are special atoms, used as boolean values. The class <a href="clojang/current/clojang.jinterface.erlang.boolean.html">boolean</a> can be used to represent these.</p>
<p>Lists in Erlang are also used to describe sequences of printable characters (strings). A convenience class <a href="clojang/current/clojang.jinterface.erlang.string.html">string</a> is provided to represent Erlang strings.</p>
<h2><a href="#nodes" name="nodes"></a>Nodes</h2>
<p>A node as defined by Erlang/OTP is an instance of the Erlang Runtime System, a virtual machine roughly equivalent to a JVM. Each node has a unique name in the form of an identifier composed partly of the hostname on which the node is running, e.g <code>gurka@sallad.com</code>. Several such nodes can run on the same host as long as their names are unique. The class <a href="clojang/current/clojang.jinterface.otp.nodes.html#var-NodeObject">node</a> represents an Erlang node. It is created with a name and optionally a port number on which it listens for incoming connections. Before creating an instance of <a href="clojang/current/clojang.jinterface.otp.nodes.html#var-NodeObject">node</a>, ensure that EPMD is running on the host machine. See the Erlang documentation for more information about EPMD. In this example, the host name is appended automatically to the identifier, and the port number is chosen by the underlying system:</p>
<pre><code class="clojure">=&gt; (require '[clojang.jinterface.otp.nodes :as nodes])
nil
=&gt; (def gurka (nodes/node "gurka"))
#'user/node
</code></pre>
<h2><a href="#mailboxes" name="mailboxes"></a>Mailboxes</h2>
<p>Erlang processes running on an Erlang node are identified by process identifiers (pids) and, optionally, by registered names unique within the node. Each Erlang process has an implicit mailbox that is used to receive messages; the mailbox is identified with the pid of the process.</p>
<p>JInterface provides a similar mechanism with the class <a href="erlang/java/com/ericsson/otp/erlang/OtpMbox.html">OtpMbox</a>, a mailbox that can be used to send and receive messages asynchronously. Each OtpMbox is identified with a unique pid and , optionally, a registered name unique within the <a href="erlang/java/com/ericsson/otp/erlang/OtpMbox.html">OtpMbox</a>.</p>
<p>Applications are free to create mailboxes as necessary. This is done as follows:</p>
<pre><code class="clojure">user=&gt; (def mbox (nodes/create-mbox gurka))
#'user/mbox
</code></pre>
<p>or like this:</p>
<pre><code class="clojure">=&gt; (require '[clojang.jinterface.otp.messaging :as messaging])
nill
user=&gt; (def mbox (messaging/mbox gurka))
#'user/mbox
</code></pre>
<p>The mailbox created in the above example has no registered name, although it does have a pid. The pid can be obtained from the mailbox and included in messages sent from the mailbox, so that remote processes are able to respond.</p>
<p>An application can register a name for a mailbox, either when the mailbox is initially created:</p>
<pre><code class="clojure">user=&gt; (def mbox (nodes/create-mbox gurka "server"))
#'user/mbox
</code></pre>
<p>or later on, if need be. You may either use the <code>register-mbox</code> function for the Node):</p>
<pre><code class="clojure">=&gt; (nodes/register-mbox gurka "server2" mbox)
true
</code></pre>
<p>or the <code>register-name</code> function for the Mbox:</p>
<pre><code class="clojure">=&gt; (messaging/register-name mbox "server3")
true
</code></pre>
<p>Registered names are usually necessary in order to start communication, since it is impossible to know in advance the pid of a remote process. If a well-known name for one of the processes is chosen in advance and known by all communicating parties within an application, each mailbox can send an initial message to the named mailbox, which then can identify the sender pid.</p>
<h2><a href="#connections" name="connections"></a>Connections</h2>
<p>It is not necessary to explicitly set up communication with a remote node. Simply sending a message to a mailbox on that node will cause the OtpNode to create a connection if one does not already exist. Once the connection is established, subsequent messages to the same node will reuse the same connection.</p>
<p>It is possible to check for the existence of a remote node before attempting to communicate with it. Here we send a ping message to the remote node to see if it is alive and accepting connections. Paste the following function in your REPL:</p>
<pre><code class="clojure">(defn print-liveliness [node other]
  (if (nodes/ping node other 1000)
    (println "It's aliiiive!")
    (println "Mate, this node wouldn't go 'voom' if ...")))
</code></pre>
<p>Now let’s use it:</p>
<pre><code class="clojure">user=&gt; (print-liveliness gurka "gurka")
It's aliiiive!
nil
user=&gt; (print-liveliness gurka "nohost")
Mate, this node wouldn't go 'voom' if ...
nil
</code></pre>
<p>If the call to <code>(nodes/ping ...)</code> succeeds, a connection to the remote node has been established. Note that it is not necessary to ping remote nodes before communicating with them, but by using ping you can determine if the remote exists before attempting to communicate with it.</p>
<p>Connections are only permitted by nodes using the same security cookie. The cookie is a short string provided either as an argument when creating <a href="clojang/current/clojang.jinterface.otp.nodes.html#var-NodeObject">node</a> objects, or found in the user’s home directory in the file <code>.erlang.cookie</code>. When a connection attempt is made, the string is used as part of the authentication process. If you are having trouble getting communication to work, use the trace facility (described later in this document) to show the connection establishment. A likely problem is that the cookies are different.</p>
<p>Connections are never broken explicitly. If a node fails or is closed, a connection may be broken however.</p>
<h2><a href="#transport-factory" name="transport-factory"></a>Transport Factory</h2>
<p>All necessary connections are made using methods of <a href="erlang/java/com/ericsson/otp/erlang/OtpTransportFactory.html">OtpTransportFactory</a> interface. Default OtpTransportFactory implementation is based on standard Socket class. User may provide custom transport factory as needed. See java doc for details.</p>
<h2><a href="#sending-and-receiving-messages" name="sending-and-receiving-messages"></a>Sending and Receiving Messages</h2>
<p>Messages sent with this package must be instances of <a href="clojang/current/clojang.jinterface.erlang.object.html">object</a> or one of its subclasses. Message can be sent to processes or pids, either by specifying the pid of the remote, or its registered name and node.</p>
<p>In this example, we create a message containing our own pid so the echo process can reply:</p>
<pre><code class="clojure">=&gt; (require '[clojang.jinterface.erlang.types :as types])
nil
=&gt; (def msg (into-array (types/object) [(messaging/self mbox)
                                        (types/atom "hello, world")]))
#'user/msg
=&gt; (messaging/register-name mbox "echo")
true
=&gt; (messaging/send mbox "echo" "gurka" (types/tuple msg))
nil
=&gt; (messaging/receive mbox)
#object[com.ericsson.otp.erlang.OtpErlangTuple
        0xeed771a
        "{#Pid&lt;gurka@mndltl01.1.0&gt;,'hello, world'}"]
</code></pre>
<p>You can also send messages from Erlang VMs to your <code>node</code>’s mailbox named <code>"echo"</code>. Before you do that, though, start listening in your Clojure REPL:</p>
<pre><code class="clojure">=&gt; (messaging/receive mbox)
</code></pre>
<p>Next, start up LFE (Lisp Flavoured Erlang) on the same machine with a short name:</p>
<pre><code class="bash">$ /path/to/bin/lfe -sname lfe
LFE Shell V7.2 (abort with ^G)
(clojang-lfe@mndltl01)&gt;
</code></pre>
<p>Once you’re in the REPL, you’re ready to send a message:</p>
<pre><code class="cl">(clojang-lfe@mndltl01)&gt; (! #(echo gurka@mndltl01) #(hej!))
#(hej!)
</code></pre>
<p>Looking at the Clojure REPL, you’ll see that your <code>receive</code> call has finished and you now have some data:</p>
<pre><code class="clojure">#object[com.ericsson.otp.erlang.OtpErlangTuple 0x4a377f4e "{'hej!'}"]
</code></pre>
<h2><a href="#sending-arbitrary-data" name="sending-arbitrary-data"></a>Sending Arbitrary Data</h2>
<p>TBD</p>
<h2><a href="#linking-to-remote-processes" name="linking-to-remote-processes"></a>Linking to Remote Processes</h2>
<p>TBD</p>
<h2><a href="#using-epmd" name="using-epmd"></a>Using EPMD</h2>
<p>TBD</p>
<h2><a href="#remote-procedure-calls" name="remote-procedure-calls"></a>Remote Procedure Calls</h2>
<p>An Erlang node acting as a client to another Erlang node typically sends a request and waits for a reply. Such a request is included in a function call at a remote node and is called a remote procedure call. Remote procedure calls are supported through the <a href="http://oubiwann.github.io/clojang/current/clojang.jinterface.otp.connection.html#var-ConnectionObject">connection</a> Clojure protocol. The following example shows how the <code>connection</code> protocol is used for remote procedure calls:</p>
<pre><code class="clojure">(require '[clojang.jinterface.otp.connection :as connection])
(def self (nodes/self "client"))
(def other (nodes/peer "clojang-lfe@mndltl01"))
(def connx (nodes/connect self other))

(connection/!rpc connx "erlang" "date" (types/list))
(connection/receive-rpc connx)
#object[com.ericsson.otp.erlang.OtpErlangTuple 0x385465c1 "{2016,1,30}"]
</code></pre></div></div></div></body></html>