<!DOCTYPE html PUBLIC ""
    "">
<html><head><meta charset="UTF-8" /><title>The APIs</title><link rel="stylesheet" type="text/css" href="css/default.css" /><link rel="stylesheet" type="text/css" href="highlight/atom-one-dark.css" /><script type="text/javascript" src="highlight/highlight.pack.js"></script><script type="text/javascript" src="js/jquery.min.js"></script><script type="text/javascript" src="js/page_effects.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div id="header"><h2>Generated by <a href="https://github.com/weavejester/codox">Codox</a> with the <a href="https://github.com/clojang/codox-theme">Clojang UI</a> theme</h2><h1><a href="index.html"><span class="project-title"><span class="project-name">jiface</span> <span class="project-version">0.5.0-SNAPSHOT</span></span></a></h1></div><div class="sidebar primary"><h3 class="no-link"><span class="inner">Project</span></h3><ul class="index-link"><li class="depth-1 "><a href="index.html"><div class="inner">Index</div></a></li></ul><h3 class="no-link"><span class="inner">Topics</span></h3><ul><li class="depth-1  current"><a href="05-apis.html"><div class="inner"><span>The APIs</span></div></a></li><li class="depth-1 "><a href="10-low-level-api.html"><div class="inner"><span>jiface User's Guide</span></div></a></li><li class="depth-1 "><a href="80-changes.html"><div class="inner"><span>Breaking Changes</span></div></a></li><li class="depth-1 "><a href="98-other-resources.html"><div class="inner"><span>Other Resources</span></div></a></li><li class="depth-1 "><a href="99-other-versions.html"><div class="inner"><span>API Docs (All Versions)</span></div></a></li></ul><h3 class="no-link"><span class="inner">Namespaces</span></h3><ul><li class="depth-1"><div class="no-link"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>jiface</span></div></div></li><li class="depth-2"><a href="jiface.erlang.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>erlang</span></div></a></li><li class="depth-3 branch"><a href="jiface.erlang.atom.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>atom</span></div></a></li><li class="depth-3 branch"><a href="jiface.erlang.bitstr.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>bitstr</span></div></a></li><li class="depth-3 branch"><a href="jiface.erlang.float.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>float</span></div></a></li><li class="depth-3 branch"><a href="jiface.erlang.int.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>int</span></div></a></li><li class="depth-3 branch"><a href="jiface.erlang.list.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>list</span></div></a></li><li class="depth-3 branch"><a href="jiface.erlang.map.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>map</span></div></a></li><li class="depth-3 branch"><a href="jiface.erlang.object.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>object</span></div></a></li><li class="depth-3 branch"><a href="jiface.erlang.pid.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>pid</span></div></a></li><li class="depth-3 branch"><a href="jiface.erlang.port.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>port</span></div></a></li><li class="depth-3 branch"><a href="jiface.erlang.ref.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>ref</span></div></a></li><li class="depth-3 branch"><a href="jiface.erlang.string.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>string</span></div></a></li><li class="depth-3 branch"><a href="jiface.erlang.tuple.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>tuple</span></div></a></li><li class="depth-3"><a href="jiface.erlang.types.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>types</span></div></a></li><li class="depth-2"><a href="jiface.otp.html"><div class="inner"><span class="tree" style="top: -424px;"><span class="top" style="height: 433px;"></span><span class="bottom"></span></span><span>otp</span></div></a></li><li class="depth-3 branch"><a href="jiface.otp.connection.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>connection</span></div></a></li><li class="depth-3 branch"><a href="jiface.otp.messaging.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>messaging</span></div></a></li><li class="depth-3 branch"><a href="jiface.otp.nodes.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>nodes</span></div></a></li><li class="depth-3 branch"><a href="jiface.otp.streams.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>streams</span></div></a></li><li class="depth-3"><a href="jiface.otp.transport.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>transport</span></div></a></li><li class="depth-2"><a href="jiface.util.html"><div class="inner"><span class="tree" style="top: -176px;"><span class="top" style="height: 185px;"></span><span class="bottom"></span></span><span>util</span></div></a></li></ul></div><div class="document" id="content"><div class="doc"><div class="markdown"><h1><a href="#the-apis" name="the-apis"></a>The APIs</h1>
<p>There are three APIs to chose from if you wish to interact with Erlang-compatible nodes from the JVM:</p>
<ul>
  <li><code>JInterface</code> - The Ericsson/Erlang-maintained Java implementation of the  Erlang communication protocol</li>
  <li><code>jiface</code> - A Clojure library that provides a very thin idomatic Clojure  wrapper around <code>JInterface</code></li>
  <li><code>clojang</code> - A Clojure library that attempts to make communications with  Erlang from Clojure as Clojure-native feeling as possible, eliminating as  much boilerplate as possible</li>
</ul>
<p>The differences are discussed below and demonstrated with a working example, contrasted in all three.</p>
<h2><a href="#jinterface" name="jinterface"></a>JInterface</h2>
<p>JInterface is an invaluable tool for projects that need to have JVM and Erlang VM languages communicating with each other. However, it is rather verbose (regardless of which JVM language you use) and feels cumbersome to use from Clojure. The syntatical burden and often anti-inuitive usage is sometimes enough to discourage experimentation and play (the latter being an essential ingrediates for innovation :-)).</p>
<p>The code below should be contrasted with the two examples for Clojang which have been written in its low- and high-level APIs. It is meant to show the awkwardness of using JInterface from Clojure. Clojure applications built using JInterface get very ugly, very quickly, especially with all the parsing of Erlang data types (JInterface objects).</p>
<pre><code class="clojure">(import '[com.ericsson.otp.erlang
           OtpErlangObject
           OtpErlangAtom
           OtpErlangTuple
           OtpNode
           OtpMbox])

(def gurka (new OtpNode "gurka"))
(def inbox (.createMbox gurka))
(.registerName inbox "echo")

(def msg (into-array
           OtpErlangObject
           [(.self inbox)
            (new OtpErlangAtom "hello, world")]))

(.send inbox "echo" "gurka" (new OtpErlangTuple msg))
(.receive inbox)

#object[com.ericsson.otp.erlang.OtpErlangTuple
        0x4c9e3fa6
        "{#Pid&lt;gurka@host.1.0&gt;,'hello, world'}"]
</code></pre>
<p>From LFE (started with <code>-sname lfe</code>):</p>
<pre><code class="cl">(clojang-lfe@host)&gt; (! #(echo gurka@host) `#(,(self) hej!))
#(&lt;0.35.0&gt; hej!)
</code></pre>
<p>Then back in Clojure:</p>
<pre><code class="clj">(def data (.receive inbox))
(def lfe-pid (.elementAt data 0))
(def lfe-msg (-&gt; data
                 (.elementAt 1)
                 (.toString)
                 (clojure.string/replace "'" "")
                 (keyword)))
(.send inbox lfe-pid (new OtpErlangTuple msg))
</code></pre>
<p>Finally, back in LFE:</p>
<pre><code class="cl">(clojang-lfe@host)&gt; (c:flush)
Shell got {&lt;5926.1.0&gt;,'hello, world'}
</code></pre>
<h2><a href="#low-level-clojure-api" name="low-level-clojure-api"></a>Low-level Clojure API</h2>
<p>The first step towards making JInterface more usable from Clojure was to write a Clojure wrapper for it â€“ a low-level one that is essentially identical to native JInterface, but utilises Clojure idioms. This will be useful for anyone from a functional programming background who wants low-level access to JInterface via idiomatic Clojure. This is the <a href="https://github.com/clojang/jiface">jiface</a> project.</p>
<p>Here is the example above, rewritten using <code>jiface</code>:</p>
<pre><code class="clj">(require '[jiface.erlang.tuple :as tuple]
         '[jiface.erlang.types :as types]
         '[jiface.otp.nodes :as nodes]
         '[jiface.otp.messaging :as messaging])

(def gurka (nodes/node "gurka"))
(def inbox (nodes/create-mbox gurka))
(messaging/register-name inbox "echo")

(def msg (into-array
           (types/object)
           [(messaging/self inbox)
            (types/atom "hello, world")]))

(messaging/send inbox "echo" "gurka" (types/tuple msg))
(messaging/receive inbox)
</code></pre>
<p>From LFE (started with <code>-sname lfe</code>):</p>
<pre><code class="cl">(clojang-lfe@host)&gt; (! #(echo gurka@host) `#(,(self) hej!))
#(&lt;0.35.0&gt; hej!)
</code></pre>
<p>Then back in Clojure:</p>
<pre><code class="clj">(def data (messaging/receive inbox))
(def lfe-pid (tuple/get-element data 0))
(def lfe-msg (-&gt; data
                 (tuple/get-element 1)
                 (str)
                 (clojure.string/replace "'" "")
                 (keyword)))
(messaging/send inbox lfe-pid (types/tuple msg))
</code></pre>
<p>Finally, back in LFE:</p>
<pre><code class="cl">(clojang-lfe@host)&gt; (c:flush)
Shell got {&lt;5926.1.0&gt;,'hello, world'}
</code></pre>
<p>As you can see, the <code>jiface</code> version of the example is essentially the same thing â€“ as it should be â€“ with the difference being that instead of calling methods on Java objects, youâ€™re calling Clojure functions (well, protocol implementations). Itâ€™s a bit clearner and certainly something Clojurians will be more comfortable with, but weâ€™ve only dealt with one layer of translation: from Java to Clojure. Thereâ€™s still another one: how to make a Java translation of Erlang more sensible in Clojure. Ideally, it would be as simple and straight-forward as when connecting to nodes from LFE.</p>
<h2><a href="#high-level-clojure-api" name="high-level-clojure-api"></a>High-level Clojure API</h2>
<p>The next step is to use a higher-level API that wraps the low-level API, one that automatically performns the necessary type conversions of function parameters and returned results. This would allow one to write the sort of Clojure one would normally do, without having to cast to Erlang types as is necessary in the low-level Clojure API. This work is captured in a separate project, <a href="https://github.com/clojang/clojang">Clojang</a>.</p>
<p>This high-level Clojang API is intended for Clojure application developers who wish to integrate with languages running on the Erlang VM without having to compromise on the Clojure side. It is anticipated that <code>clojang</code> will be far preferrable to developers over <code>jiface</code>.</p>
<p>Below is the example above, rewritten using <code>clojang</code>. Before going over it, though, youâ€™ll note that when you start a <code>clojang</code> Clojure REPL, youâ€™ll see the Clojang logo/splash screen. Whatâ€™s happening behind the scenes is that the Clojang Java agent is starting up a Clojang node in a way analogous to when you start LFE with the <code>-sname lfe</code> parameter. In the latter case, LFE creates an Erlang VM thatâ€™s capable of communicating with other nodes. Similarly, what we have with Clojang is a default Clojure node that is created for us by the agent (complete with its own mbox) that is capable of communicating with other nodes.</p>
<p>As such, in this example we donâ€™t need to set up a node and a message box for that node; weâ€™ll be using the default one created by the agent). Given this, weâ€™re ready to start sending messages immediately:</p>
<pre><code class="clj">(require '[clojang.core :as clojang :refer [! receive self]])

(! [(self) "hello, world"])
(receive)
</code></pre>
<p>From LFE (started with <code>-sname lfe</code>):</p>
<pre><code class="cl">(clojang-lfe@host)&gt; (register 'lferepl (self))
(clojang-lfe@host)&gt; (! #(default clojang@host) `#(,(self) hej!))
</code></pre>
<p>Then back in Clojure:</p>
<pre><code class="clj">(let [[pid msg] (receive)] (println "Got msg" msg))
(! :lferepl "clojang-lfe@host" [(self) "hello, world"])
</code></pre>
<p>Then, back in LFE:</p>
<pre><code class="cl">(clojang-lfe@clojang)&gt; (c:flush)
Shell got {&lt;5926.1.0&gt;,"hello, world"}
</code></pre>
<p>Finally, with this high-level API, we can see a level of usability for the Erlang protocol communication in Clojure that is on par with that in LFE itself.</p></div></div></div></body></html>